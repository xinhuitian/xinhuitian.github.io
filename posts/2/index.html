<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>XinhuiTian&#39;s Note</title>
  <meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://yous.github.io/posts/2/">
  
  
  <link rel="alternate" type="application/rss+xml" title="XinhuiTian&#39;s Note" href="https://yous.github.io/feed.xml">

  

  
  <meta property="og:title" content="XinhuiTian&#39;s Note">
  <meta property="og:site_name" content="XinhuiTian&#39;s Note">
  <meta property="og:url" content="https://yous.github.io/posts/2/">
  <meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="XinhuiTian&#39;s Note">
  <meta name="twitter:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">XinhuiTian&#39;s Note</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2022/09/19/C++-%E5%A4%9A%E6%80%81-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0/">多态：概念与实现</a>
            
          </h1>

          <p class="post-meta">
            Sep 19, 2022
            
               •
  
    
    
      
        <a href="/categories/c/">C++</a>
      
    
      
    
      
    
      
    
      
    
  




            
            
          </p>
        </header>

        <div class="post-content">
          <h1>概念</h1>

<p>多态（polymorphism），字面意思的解释是指一个 function or object 可以在不同情况下有不同的行为。多态从实现上大致分为静态多态（static polymorphism）和动态多态（dynamic polymorphism）两种。</p>

<p>以下三节主要参考：<a href="https://thecppdev.com/2022/05/22/polymorphism-in-c/?noamp=available">Polymorphism in C++ - cppdev</a> 与 <a href="https://thecppdev.com/2022/05/26/dynamic-polymorphism-performance/?noamp=available">Performance of dynamic polymorphism - cppdev</a> 两篇文章</p>

<h2>动态多态（Dynamic Polymorphism）</h2>

<p>动态指是真正执行的代码是在 <em>运行时</em> 才能确定的。
实现主要依赖于 virtual function 的 overriding。</p>

<p>example：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"doSomething from Base</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doOtherThing</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"doOtherThing from Base</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span> <span class="k">override</span> <span class="c1">// override implies virtual</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"doSomething from Derived</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">()};</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">// prints "doSomething from Derived"</span>
</code></pre></div></div>

<p>当一个 function 被 virtual 定义时，编译器会得知这个 function 可能会在子类中被重定义，因此只能在 runtime 时才能得到正确的执行代码。那么程序如何在运行时找到正确的 function？这里就需要依赖 vtable 与 vptr 结构。</p>

<h3>vtable 与 vptr</h3>

<p>每个包含 virtual function 的 class 都会包含一个 vptr 用于指向一个 vtable 结构。vtable 用于存储一个 class 的所有 virtual function 的地址信息。</p>

<p><img src="/assets/vtable.jpg" alt="vtable" /></p>

<p>通过 -O0 得到的编译代码中，vtable 信息如下：</p>

<p><img src="/assets/compile.jpg" alt="compile" /></p>

<p>具体的编译结果可见：<a href="https://godbolt.org/z/6enMqnoGW">Compiler Explorer</a></p>

<h2>静态多态（Static Polymorphism）</h2>

<p>静态多态的静态是指 object 的类型以及要调用的 function 都是在编译器就决定好的。通常实现静态多态的方式主要包括：</p>

<ul>
  <li>function overloading</li>
  <li>operator overloading</li>
  <li>templates</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function overloading</span>
<span class="kt">double</span> <span class="nf">do_oper</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// #1</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">double</span> <span class="n">do_oper</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// #2</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">auto</span> <span class="n">oper1</span> <span class="o">=</span> <span class="n">do_oper</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// #1 is called</span>
<span class="k">auto</span> <span class="n">oper2</span> <span class="o">=</span> <span class="n">do_oper</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span> <span class="c1">// #2 is called</span>

<span class="c1">// operator overloading(already provided by compiler)</span>
<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// operator+ adds the integers</span>
<span class="k">auto</span> <span class="n">concat</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"1"</span><span class="p">}</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"2"</span><span class="p">};</span> <span class="c1">// operator+ concatenates the strings</span>

<span class="k">auto</span> <span class="n">sum_double</span> <span class="o">=</span> <span class="n">do_sum</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span> <span class="c1">// double do_sum(double a, double b) is called</span>
<span class="c1">// template</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="n">do_sum</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">auto</span> <span class="n">sum_int</span> <span class="o">=</span> <span class="n">do_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// int do_sum(int a, int b) is called</span>
</code></pre></div></div>

<p>此外，使用 template 实现静态多态还有一种专门的设计方式：CRTP（curiously recurring template pattern ）
其定义方式如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Z</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Y</span> <span class="p">{};</span>
 
<span class="k">class</span> <span class="nc">X</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Y</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="p">{};</span>
</code></pre></div></div>

<p>通常的设计是在 base class 中，实现一个函数，将 base 强转为 T 对应的 class，调用其对应的 function</p>

<p>example：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span> 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Derived</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">name</span><span class="p">()</span> <span class="p">{</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">impl</span><span class="p">();</span> <span class="p">}</span> <span class="p">};</span>
 
<span class="k">struct</span> <span class="nc">D1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">D1</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">impl</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"D1::impl()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">D2</span><span class="o">&gt;</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">impl</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"D2::impl()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Base</span><span class="o">&lt;</span><span class="n">D1</span><span class="o">&gt;</span> <span class="n">b1</span><span class="p">;</span> <span class="n">b1</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
    <span class="n">Base</span><span class="o">&lt;</span><span class="n">D2</span><span class="o">&gt;</span> <span class="n">b2</span><span class="p">;</span> <span class="n">b2</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
 
    <span class="n">D1</span> <span class="n">d1</span><span class="p">;</span> <span class="n">d1</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
    <span class="n">D2</span> <span class="n">d2</span><span class="p">;</span> <span class="n">d2</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// output:</span>
<span class="n">D1</span><span class="o">::</span><span class="n">impl</span><span class="p">()</span>
<span class="n">D2</span><span class="o">::</span><span class="n">impl</span><span class="p">()</span>
<span class="n">D1</span><span class="o">::</span><span class="n">impl</span><span class="p">()</span>
<span class="n">D2</span><span class="o">::</span><span class="n">impl</span><span class="p">()</span>
</code></pre></div></div>

<h2>动态多态的性能问题</h2>

<p>运行时才能确定真正执行的函数，会带来以下问题：</p>

<ul>
  <li>额外的存储空间（vptr）</li>
  <li>额外的重定向 (pointer dereference)</li>
  <li>无法 inline 化</li>
  <li>cache miss</li>
</ul>

<h3>额外的存储空间与重定向</h3>

<p>相比 native 的函数调用，多了一步查表操作
例子：<a href="https://quick-bench.com/q/E9ZRucuYA6zh7lHeN3wsyGNWUvo">https://quick-bench.com/q/E9ZRucuYA6zh7lHeN3wsyGNWUvo</a>
因此，对于不会被用作 base 的 class，不要为其定义 virtual functions，尤其是 virtual deconstructor：<a href="https://flylib.com/books/en/2.887.1.19/1/">Effective C++：Item 7</a></p>

<h3>无法 inline 化</h3>

<p>当 virtual function 需要通过 vptr 来调用时，compiler 无法对其进行 inline 优化</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">doSomething</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
 
<span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">// this can be inlined</span>
 
<span class="n">Base</span><span class="o">*</span> <span class="n">b1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
<span class="n">b1</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">// this cannot</span>
<span class="k">delete</span> <span class="n">b1</span><span class="p">;</span>
</code></pre></div></div>

<h3>cache miss</h3>

<p>使用 virtual function 带来的 cache miss 会远大于使用 template 的情况</p>

<p>example:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">DynamicPolymorphism</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseDP</span><span class="o">*&gt;</span> <span class="n">ptrs</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ptrs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">DerivedDP</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// profiling</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ptr</span> <span class="o">:</span> <span class="n">ptrs</span><span class="p">)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
  <span class="c1">// Make sure the variable is not optimized away by compiler</span>
  <span class="c1">// benchmark::DoNotOptimize(created_string);</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ptr</span> <span class="o">:</span> <span class="n">ptrs</span><span class="p">)</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">StaticPolymorphism</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BaseSP</span><span class="o">&lt;</span><span class="n">DerivedSP</span><span class="o">&gt;*&gt;</span> <span class="n">ptrs</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ptrs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">BaseSP</span><span class="o">&lt;</span><span class="n">DerivedSP</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// profilling</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ptr</span> <span class="o">:</span> <span class="n">ptrs</span><span class="p">)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ptr</span> <span class="o">:</span> <span class="n">ptrs</span><span class="p">)</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用 cachegrind 和 qcachegrind（mac 上，linux 是 kcachegrind） 查看 cache 命中情况：
<img src="/assets/qcache.jpg" alt="qcache" /></p>

<h1>其他替代 virtual function 的方法</h1>

<h2>基于 std::variant</h2>

<p>std::variant 是 c++17 引入的类型安全的 union 结构。一个 std::variant 实例只能是其定义的一种类型，极少可能会达到 no value 的状态 ([std::variant<Types...>::valueless_by_exception](https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception)) 。</Types...></p>

<p>用 std::variant 实现多态，需要基于一种 visitor 设计模式，即定义好所有的类型，对每个类型编写对应的 function 实现，在实际调用时基于 variant 的 value 类型选择要执行的 function。</p>

<p>example：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Type</span>
<span class="p">{</span>
    <span class="n">Type</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="o">:</span> <span class="n">type_</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">type_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">f_impl</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">f_impl</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// 定义 variant</span>
<span class="k">using</span> <span class="n">VAR</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">VAR</span> <span class="n">var</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">va</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">va</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="n">va</span> <span class="o">=</span> <span class="n">B</span><span class="p">();</span>
    <span class="n">var</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">/// visit with std::visit</span>
<span class="kt">int</span> <span class="n">v_total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">CallFunc</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">v_total</span> <span class="o">+=</span> <span class="n">a</span><span class="p">.</span><span class="n">f_impl</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">v_total</span> <span class="o">+=</span> <span class="n">b</span><span class="p">.</span><span class="n">f_impl</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">CallFunc</span><span class="p">{},</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">/// visit with holds_alternative</span>
<span class="kt">int</span> <span class="n">callFImpl</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">).</span><span class="n">f_impl</span><span class="p">();</span>
    <span class="p">}</span> 

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">).</span><span class="n">f_impl</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">callFImpl</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<p>std::variant 与 virtual function 的比较：
<img src="/assets/variant.jpg" alt="variant" /></p>

<p>性能比较：
<a href="https://quick-bench.com/q/Mcclomh03nu8nDCgT3T302xKnXY">Quick C++ Benchmarks</a></p>

<h2>基于 concept</h2>

<p>主要基于 <a href="https://www.fluentcpp.com/2020/09/11/replacing-crtp-static-polymorphism-with-concepts/">Replacing CRTP Static Polymorphism With Concepts - Fluent C++</a> 整理</p>

<p>CRTP 的问题：</p>

<ul>
  <li>多了一层间接的调用语意，可读性比较差，比如下面的代码，需要实现不同的 log 级别输出， 以 CRTP 的写法如下：</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TLoggerImpl</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Logger</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">LogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Impl</span><span class="p">().</span><span class="n">DoLogDebug</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">LogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Impl</span><span class="p">().</span><span class="n">DoLogInfo</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">LogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Impl</span><span class="p">().</span><span class="n">DoLogError</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="nl">private:</span>
 <span class="o">*</span><span class="n">TLoggerImpl</span><span class="o">&amp;</span> <span class="n">Impl</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TLoggerImpl</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="o">*</span>  <span class="k">friend</span> <span class="n">TLoggerImpl</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TLoggerImpl</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">LogToAll</span><span class="p">(</span><span class="n">Logger</span><span class="o">&lt;</span><span class="n">TLoggerImpl</span><span class="o">&gt;&amp;</span> <span class="n">logger</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogDebug</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogInfo</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">CustomLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Logger</span><span class="o">&lt;</span><span class="n">CustomLogger</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">DoLogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Debug] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">DoLogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Info] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">DoLogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Error] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">TestLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Logger</span><span class="o">&lt;</span><span class="n">TestLogger</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">DoLogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">DoLogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">DoLogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="p">};</span>


<span class="n">CustomLogger</span> <span class="n">custom_logger</span><span class="p">;</span>
<span class="n">LogToAll</span><span class="p">(</span><span class="n">custom_logger</span><span class="p">,</span> <span class="err">“</span><span class="n">Hello</span> <span class="n">World</span><span class="err">”</span><span class="p">);</span>
<span class="n">TestLogger</span> <span class="n">test_logger</span><span class="p">;</span>
<span class="n">LogToAll</span><span class="p">(</span><span class="n">test_logger</span><span class="p">,</span> <span class="err">“</span><span class="n">Hello</span> <span class="n">World</span><span class="err">”</span><span class="p">);</span>
</code></pre></div></div>

<p>concept 在 c++ 20 引入，用于为 template 的 type 规定限制条件，以下是上面 Log 功能的 concept 实现。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 定义一个 concept</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TLoggerImpl</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">LoggerLike</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">TLoggerImpl</span> <span class="n">log</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">log</span><span class="p">.</span><span class="n">LogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">{});</span>
  <span class="n">log</span><span class="p">.</span><span class="n">LogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">{});</span>
  <span class="n">log</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">{});</span>
<span class="p">};</span>

<span class="c1">/// 定义调用类1</span>
<span class="k">struct</span> <span class="nc">CustomLogger</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">LogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Debug] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">LogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Info] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">LogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Error] "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// 定义调用类2</span>
<span class="k">struct</span> <span class="nc">TestLogger</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">LogDebug</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">LogInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">LogError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// 定义调用方法</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">LoggerLike</span> <span class="n">TLogger</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">LogToAll</span><span class="p">(</span><span class="n">TLogger</span><span class="o">&amp;</span> <span class="n">logger</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogDebug</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogInfo</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="n">logger</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">CustomLoggerImpl</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">TestLoggerImpl</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>

<span class="k">using</span> <span class="n">CustomLogger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">&lt;</span><span class="n">CustomLoggerImpl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestLogger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">&lt;</span><span class="n">TestLoggerImpl</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">/// 实际调用</span>
<span class="n">CustomLogger</span> <span class="n">custom_logger</span><span class="p">;</span>
<span class="n">LogToAll</span><span class="p">(</span><span class="n">custom_logger</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>
<span class="n">TestLogger</span> <span class="n">test_logger</span><span class="p">;</span>
<span class="n">LogToAll</span><span class="p">(</span><span class="n">test_logger</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>
</code></pre></div></div>

<h2>Reference</h2>

<ul>
  <li><a href="https://thecppdev.com/2022/05/22/polymorphism-in-c/?noamp=available">Polymorphism in C++ - cppdev</a></li>
  <li><a href="https://thecppdev.com/2022/05/26/dynamic-polymorphism-performance/?amp=1">Performance of dynamic polymorphism - cppdev</a></li>
  <li><a href="https://en.cppreference.com/w/cpp/language/crtp">Curiously Recurring Template Pattern - cppreference.com</a></li>
  <li><a href="https://flylib.com/books/en/2.887.1.19/1/">Item 7: Declare destructors virtual in polymorphic base classes</a></li>
  <li><a href="https://valgrind.org/docs/manual/cg-manual.html">https://valgrind.org/docs/manual/cg-manual.html</a></li>
  <li><a href="https://en.cppreference.com/w/cpp/utility/variant">https://en.cppreference.com/w/cpp/utility/variant</a></li>
  <li><a href="http://cpptruths.blogspot.com/2018/02/inheritance-vs-stdvariant-based.html">Inheritance vs std::variant</a></li>
  <li><a href="https://stackoverflow.com/questions/57726401/stdvariant-vs-inheritance-vs-other-ways-performance">https://stackoverflow.com/questions/57726401/stdvariant-vs-inheritance-vs-other-ways-performance</a></li>
  <li><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></li>
  <li><a href="https://quick-bench.com/q/qKvbnsqH1MILeQNWg3XpFfS9f3s">https://quick-bench.com/q/qKvbnsqH1MILeQNWg3XpFfS9f3s</a></li>
  <li><a href="https://gist.github.com/GuillaumeDua/b0f5e3a40ce49468607dd62f7b7809b1#concepts-as-static--runtime-polymorphism-providers">Concept-based polymorphism in modern C++ · GitHub</a></li>
  <li><a href="https://www.cppfiddler.com/2019/06/09/concept-based-interfaces/">Interfaces with C++20 Concepts  cppfiddler</a></li>
  <li><a href="https://www.fluentcpp.com/2020/09/11/replacing-crtp-static-polymorphism-with-concepts/">Replacing CRTP Static Polymorphism With Concepts - Fluent C++</a></li>
</ul>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    

    
      <a class="next" href="/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; xht - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://yous.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
