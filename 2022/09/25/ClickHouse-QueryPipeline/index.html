<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>ClickHouse QueryPipeline 相关代码分析</title>
  <meta name="description" content="Overview QueryPipeline 是 CK 中一条 select query 最终的物理执行计划。本文尝试分析 QueryPipeline 的创建过程，一些相关结构之间的关联，以及各个结构所起到的作用。 本文基于 22.3.7.28-lts 版本分析。 QueryPipeline 创建 首先在 InterpreterSelectQuery 的 execute() 中，调用 query_plan.buildQueryPipeline 来生成 QueryPipelineBuilder。再通过 QueryPipelineBuilder::getPipeline(QueryPipelineBuilder) 来创建真正的 pipeline。 query_plan.buildQueryPipeline 首先会执行 query plan 的 optimize，之后从 source step 开始，调用每个 QueryPlanStep 的 updatePipeline，以上一个 step 生成 pipelines 作为参数，生成当前 step 的 QueryPipelineBuilder，并将其设置为 last_pipeline。等所有的 step 执行完 updatePipeline 之后，返回最后的 last_pipeline，也就是最终的 QueryPipelineBuilder。 QueryPipelineBuilder::getPipeline 中，会基于参数得 QueryPipelineBuilder 的 pipe 创建来QueryPipeline。QueryPipeline 构造时，如果发现传入得 pipe 的 numOutputPorts 大于 0， 则添加一个 ResizeProcessor，将所有的 outputs 都接到这个 ResizeProcessor 上，确保到这里多个线程的执行结果都汇总到一起。 需要注意的是，interpreter 返回结果中的 pipeline，不是最终的 pipeline，还需要以下的两步： 在 executeQuery.cpp 的 executeQueryImpl 中，对于 pulling 的 pipeline，会在最后添加一个 LimitsCheckingTransform processor，用于进行 time limit 和 size limit 的判断，以及执行信息的统计（result_rows, result_bytes, execution_time） 在 PullingAsyncPipelineExecutor 的构建时，会加上 LazyOutputFormat processor 至此 pipeline 才算构建完成。 Pipe 创建 QueryPipelineBuilder 中会包含一个 pipe 结构，这个结构主要用于进行 processors 之间的连接，是 plan 到 pipeline 转换过程中的关键结构。这里分析 pipe 的创建以及关键的连接操作。 创建 pipe 时，首先通过所有的 main Sources processors 创建。 pipe 在添加 sources 时，是每个 source 创建一个 Pipe，然后再调用 unitePipes 将所有的 Pipes 连接成一个。 Pipe construction 1 将 source 的 outputs 的 front 添加到 output_ports 中 2 将 header 设置为 output_ports.front() 的 header 3 将 source processor 添加到 processors 中 4 设置 max_parallel_streams 为 1 unitePipes 1 创建一个新的 Pipe res 2 res 的 holder 设置为最后一个 pipe 的 holder 3 res 的 header 设置为 pipes 的 common header 4 将所有 pipes 的 processors 添加到 res 的 processors 中 5 将所有 pipes 的 output_ports 添加到 res 的 output_ports 中 6 累加所有 pipes 的 max_parallel_streams，赋值给 res 的 max_parallel_streams 对于 transform processor 的添加，pipe 提供两种接口，其中 addSimpleTransform 接收一个 getter 的 transform processor 创建方法，为每个 output 创建一个对应的 transform processor，并进行连接；addTransform 直接接受一个 transform processor，将所有的 outputs 都和这一个 transform processor 进行连接。 addSimpleTransform(const ProcessorGetter &amp;amp; getter) 将 transform processor 添加给所有的 output_ports。 具体来说，对每个 output_port： 1 基于传入的 getter 函数，创建 transform processor 基于传入的 input header 和 output header 创建 input port 和 output port 2 将当前 output port 和 transform 的 input port 做 connect 3 将这个 output port 设置为 transform 的 output port 4 processors 中添加 transform addTransform(ProcessorPtr transform, OutputPort * totals, OutputPort * extremes) 将传进来的 transform processor inputs 和所有的 output ports 连接 1 获取 transform 所有的 input ports 2 将每个 input port 和 output ports 顺序连接 3 将 outputs 设置为 transform 的 outputs 4 将 outputs 中的每个 元素，都添加到 pipe 的 output_ports 中 5 将 header 设置为 output_ports 第一个的 header 6 将 transform processor 添加到 processors 中 7 设置 max_parallel_streams 为当前 max_parallel_streams 与 output_parts.size() 的最大值 其他几个问题 processors 如何进行连接 每个 processor 在创建时，会根据 input header 和 output header 来创建 input 以及 output ports。每次 pipe 添加 processor 时，会将当前的 output ports 和 processor 的 input port 连接，具体操作为： 分别设置为对方的 output_port 以及 input_port 分别设置 out_name 与 in_name 为 output 和 input processor 的 name 初始化 input.state, output.state 设置为 input.state 如果多个 processors 的 output 是同一个 processor， ExecutingGraph 如何调度 对于 inputs 来说，每个 processor 都会将 output processor 添加到 edges 中，然后调用一次 output processor 的 prepare 方法。这种汇聚 inputs 的 processor 一般是一个 ResizeProcessor，在 prepare 的时候，只负责将 input 的数据 push 到 output processor 去，然后继续返回 needData 的状态。 多个 sources 是在什么时候合并的？是否有固定的合并操作？ QueryPipeline 构造时，引入 ResizeProcessor，进行多线程 inputs 的合并，之后就都是单线程操作 ISource 的 outputs 如何初始化？ ISource 的 construction： ISource::ISource(Block header) : IProcessor({}, {std::move(header)}), output(outputs.front()) { } 用的是 IProcessor 创建时候的 outputs 的第一个，而 IProcessor 的 outputs 是基于 header 创建的， 这里主要是创建了一个带 header 的 OutputPort。header 来自于 MergeTreeBaseSelectProcessor::transformHeader 操作，该操作会基于 required columns 等信息算出来的需要实际读取的 columns，也就是 OutputPort 的 header 记录的是 ISource 要读取的列名称。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://yous.github.io/2022/09/25/ClickHouse-QueryPipeline/">
  
  
  <link rel="alternate" type="application/rss+xml" title="XinhuiTian&#39;s Note" href="https://yous.github.io/feed.xml">

  

  
  <meta property="og:title" content="ClickHouse QueryPipeline 相关代码分析">
  <meta property="og:site_name" content="XinhuiTian&#39;s Note">
  <meta property="og:url" content="https://yous.github.io/2022/09/25/ClickHouse-QueryPipeline/">
  <meta property="og:description" content="Overview QueryPipeline 是 CK 中一条 select query 最终的物理执行计划。本文尝试分析 QueryPipeline 的创建过程，一些相关结构之间的关联，以及各个结构所起到的作用。 本文基于 22.3.7.28-lts 版本分析。 QueryPipeline 创建 首先在 InterpreterSelectQuery 的 execute() 中，调用 query_plan.buildQueryPipeline 来生成 QueryPipelineBuilder。再通过 QueryPipelineBuilder::getPipeline(QueryPipelineBuilder) 来创建真正的 pipeline。 query_plan.buildQueryPipeline 首先会执行 query plan 的 optimize，之后从 source step 开始，调用每个 QueryPlanStep 的 updatePipeline，以上一个 step 生成 pipelines 作为参数，生成当前 step 的 QueryPipelineBuilder，并将其设置为 last_pipeline。等所有的 step 执行完 updatePipeline 之后，返回最后的 last_pipeline，也就是最终的 QueryPipelineBuilder。 QueryPipelineBuilder::getPipeline 中，会基于参数得 QueryPipelineBuilder 的 pipe 创建来QueryPipeline。QueryPipeline 构造时，如果发现传入得 pipe 的 numOutputPorts 大于 0， 则添加一个 ResizeProcessor，将所有的 outputs 都接到这个 ResizeProcessor 上，确保到这里多个线程的执行结果都汇总到一起。 需要注意的是，interpreter 返回结果中的 pipeline，不是最终的 pipeline，还需要以下的两步： 在 executeQuery.cpp 的 executeQueryImpl 中，对于 pulling 的 pipeline，会在最后添加一个 LimitsCheckingTransform processor，用于进行 time limit 和 size limit 的判断，以及执行信息的统计（result_rows, result_bytes, execution_time） 在 PullingAsyncPipelineExecutor 的构建时，会加上 LazyOutputFormat processor 至此 pipeline 才算构建完成。 Pipe 创建 QueryPipelineBuilder 中会包含一个 pipe 结构，这个结构主要用于进行 processors 之间的连接，是 plan 到 pipeline 转换过程中的关键结构。这里分析 pipe 的创建以及关键的连接操作。 创建 pipe 时，首先通过所有的 main Sources processors 创建。 pipe 在添加 sources 时，是每个 source 创建一个 Pipe，然后再调用 unitePipes 将所有的 Pipes 连接成一个。 Pipe construction 1 将 source 的 outputs 的 front 添加到 output_ports 中 2 将 header 设置为 output_ports.front() 的 header 3 将 source processor 添加到 processors 中 4 设置 max_parallel_streams 为 1 unitePipes 1 创建一个新的 Pipe res 2 res 的 holder 设置为最后一个 pipe 的 holder 3 res 的 header 设置为 pipes 的 common header 4 将所有 pipes 的 processors 添加到 res 的 processors 中 5 将所有 pipes 的 output_ports 添加到 res 的 output_ports 中 6 累加所有 pipes 的 max_parallel_streams，赋值给 res 的 max_parallel_streams 对于 transform processor 的添加，pipe 提供两种接口，其中 addSimpleTransform 接收一个 getter 的 transform processor 创建方法，为每个 output 创建一个对应的 transform processor，并进行连接；addTransform 直接接受一个 transform processor，将所有的 outputs 都和这一个 transform processor 进行连接。 addSimpleTransform(const ProcessorGetter &amp;amp; getter) 将 transform processor 添加给所有的 output_ports。 具体来说，对每个 output_port： 1 基于传入的 getter 函数，创建 transform processor 基于传入的 input header 和 output header 创建 input port 和 output port 2 将当前 output port 和 transform 的 input port 做 connect 3 将这个 output port 设置为 transform 的 output port 4 processors 中添加 transform addTransform(ProcessorPtr transform, OutputPort * totals, OutputPort * extremes) 将传进来的 transform processor inputs 和所有的 output ports 连接 1 获取 transform 所有的 input ports 2 将每个 input port 和 output ports 顺序连接 3 将 outputs 设置为 transform 的 outputs 4 将 outputs 中的每个 元素，都添加到 pipe 的 output_ports 中 5 将 header 设置为 output_ports 第一个的 header 6 将 transform processor 添加到 processors 中 7 设置 max_parallel_streams 为当前 max_parallel_streams 与 output_parts.size() 的最大值 其他几个问题 processors 如何进行连接 每个 processor 在创建时，会根据 input header 和 output header 来创建 input 以及 output ports。每次 pipe 添加 processor 时，会将当前的 output ports 和 processor 的 input port 连接，具体操作为： 分别设置为对方的 output_port 以及 input_port 分别设置 out_name 与 in_name 为 output 和 input processor 的 name 初始化 input.state, output.state 设置为 input.state 如果多个 processors 的 output 是同一个 processor， ExecutingGraph 如何调度 对于 inputs 来说，每个 processor 都会将 output processor 添加到 edges 中，然后调用一次 output processor 的 prepare 方法。这种汇聚 inputs 的 processor 一般是一个 ResizeProcessor，在 prepare 的时候，只负责将 input 的数据 push 到 output processor 去，然后继续返回 needData 的状态。 多个 sources 是在什么时候合并的？是否有固定的合并操作？ QueryPipeline 构造时，引入 ResizeProcessor，进行多线程 inputs 的合并，之后就都是单线程操作 ISource 的 outputs 如何初始化？ ISource 的 construction： ISource::ISource(Block header) : IProcessor({}, {std::move(header)}), output(outputs.front()) { } 用的是 IProcessor 创建时候的 outputs 的第一个，而 IProcessor 的 outputs 是基于 header 创建的， 这里主要是创建了一个带 header 的 OutputPort。header 来自于 MergeTreeBaseSelectProcessor::transformHeader 操作，该操作会基于 required columns 等信息算出来的需要实际读取的 columns，也就是 OutputPort 的 header 记录的是 ISource 要读取的列名称。">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="ClickHouse QueryPipeline 相关代码分析">
  <meta name="twitter:description" content="Overview QueryPipeline 是 CK 中一条 select query 最终的物理执行计划。本文尝试分析 QueryPipeline 的创建过程，一些相关结构之间的关联，以及各个结构所起到的作用。 本文基于 22.3.7.28-lts 版本分析。 QueryPipeline 创建 首先在 InterpreterSelectQuery 的 execute() 中，调用 que...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">XinhuiTian&#39;s Note</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">ClickHouse QueryPipeline 相关代码分析</h1>
    
    <p class="post-meta"><time datetime="2022-09-25T16:08:00+00:00" itemprop="datePublished">Sep 25, 2022</time> •
  
    
    
      
    
      
        <a href="/categories/clickhouse/">ClickHouse</a>,
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/categories/pipelineexecution/">PipelineExecution</a>
      
    
      
    
      
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2>Overview</h2>

<p>QueryPipeline 是 CK 中一条 select query 最终的物理执行计划。本文尝试分析 QueryPipeline 的创建过程，一些相关结构之间的关联，以及各个结构所起到的作用。</p>

<p>本文基于 22.3.7.28-lts 版本分析。</p>
<h2>QueryPipeline 创建</h2>

<p>首先在 InterpreterSelectQuery 的 execute() 中，调用 query_plan.buildQueryPipeline 来生成 QueryPipelineBuilder。再通过 QueryPipelineBuilder::getPipeline(QueryPipelineBuilder) 来创建真正的 pipeline。</p>

<p>query_plan.buildQueryPipeline 首先会执行 query plan 的 optimize，之后从 source step 开始，调用每个 QueryPlanStep 的 updatePipeline，以上一个 step 生成 pipelines 作为参数，生成当前 step 的 QueryPipelineBuilder，并将其设置为 last_pipeline。等所有的 step 执行完 updatePipeline 之后，返回最后的 last_pipeline，也就是最终的 QueryPipelineBuilder。</p>

<p>QueryPipelineBuilder::getPipeline 中，会基于参数得 QueryPipelineBuilder 的 pipe 创建来QueryPipeline。QueryPipeline 构造时，如果发现传入得 pipe 的 numOutputPorts 大于 0， 则添加一个 ResizeProcessor，将所有的 outputs 都接到这个 ResizeProcessor 上，确保到这里多个线程的执行结果都汇总到一起。</p>

<p>需要注意的是，interpreter 返回结果中的 pipeline，不是最终的 pipeline，还需要以下的两步：</p>

<ul>
  <li>在 executeQuery.cpp 的  executeQueryImpl 中，对于 pulling 的 pipeline，会在最后添加一个 LimitsCheckingTransform processor，用于进行 time limit 和 size limit 的判断，以及执行信息的统计（result_rows, result_bytes, execution_time）</li>
  <li>在 PullingAsyncPipelineExecutor 的构建时，会加上  LazyOutputFormat processor</li>
</ul>

<p>至此 pipeline 才算构建完成。</p>

<h2>Pipe 创建</h2>

<p>QueryPipelineBuilder 中会包含一个 pipe 结构，这个结构主要用于进行 processors 之间的连接，是 plan 到 pipeline 转换过程中的关键结构。这里分析 pipe 的创建以及关键的连接操作。</p>

<p>创建 pipe 时，首先通过所有的 main Sources processors 创建。</p>

<p>pipe 在添加 sources 时，是每个 source 创建一个 Pipe，然后再调用 unitePipes 将所有的 Pipes 连接成一个。</p>

<h3>Pipe construction</h3>

<p>1 将 source 的 outputs 的 front 添加到 output_ports 中</p>

<p>2 将 header 设置为 output_ports.front() 的 header</p>

<p>3 将 source processor 添加到 processors 中</p>

<p>4 设置 max_parallel_streams 为 1</p>

<h3>unitePipes</h3>

<p>1 创建一个新的 Pipe res</p>

<p>2 res 的 holder 设置为最后一个 pipe 的 holder</p>

<p>3 res 的 header 设置为 pipes 的 common header</p>

<p>4 将所有 pipes 的 processors 添加到 res 的 processors 中</p>

<p>5 将所有 pipes 的 output_ports 添加到 res 的 output_ports 中</p>

<p>6 累加所有 pipes 的 max_parallel_streams，赋值给 res 的 max_parallel_streams</p>

<p>对于 transform processor 的添加，pipe 提供两种接口，其中 addSimpleTransform 接收一个 getter 的 transform processor 创建方法，为每个 output 创建一个对应的 transform processor，并进行连接；addTransform 直接接受一个 transform processor，将所有的 outputs 都和这一个 transform processor 进行连接。</p>

<h3>addSimpleTransform(const ProcessorGetter &amp; getter)</h3>

<p>将 transform processor 添加给所有的 output_ports。</p>

<p>具体来说，对每个 output_port：</p>

<p>1 基于传入的 getter 函数，创建 transform processor</p>

<ul>
  <li>基于传入的 input header 和 output header 创建 input port 和 output port</li>
</ul>

<p>2 将当前 output port 和 transform 的 input port 做 connect</p>

<p>3 将这个 output port 设置为 transform 的 output port</p>

<p>4 processors 中添加 transform</p>

<h3><strong>addTransform(ProcessorPtr transform, OutputPort * totals, OutputPort * extremes)</strong></h3>

<p>将传进来的 transform processor inputs 和所有的 output ports 连接</p>

<p>1 获取 transform 所有的 input ports</p>

<p>2 将每个 input port 和 output ports 顺序连接</p>

<p>3 将 outputs 设置为 transform 的 outputs</p>

<p>4 将 outputs 中的每个 元素，都添加到 pipe 的 output_ports 中</p>

<p>5 将 header 设置为 output_ports 第一个的 header</p>

<p>6 将 transform processor 添加到 processors 中</p>

<p>7 设置 max_parallel_streams 为当前 max_parallel_streams 与 output_parts.size() 的最大值</p>

<h2>其他几个问题</h2>

<h3>processors 如何进行连接</h3>

<ul>
  <li>每个 processor 在创建时，会根据 input header 和 output header 来创建 input 以及 output ports。每次 pipe 添加 processor 时，会将当前的 output ports 和 processor 的 input port 连接，具体操作为：
    <ul>
      <li>分别设置为对方的 output_port 以及 input_port</li>
      <li>分别设置 out_name 与 in_name 为 output 和 input processor 的 name</li>
      <li>初始化 input.state, output.state 设置为 input.state</li>
    </ul>
  </li>
</ul>

<h3>如果多个 processors 的 output 是同一个 processor， ExecutingGraph 如何调度</h3>

<ul>
  <li>对于 inputs 来说，每个 processor 都会将 output processor 添加到 edges 中，然后调用一次 output processor 的 prepare 方法。这种汇聚 inputs 的 processor 一般是一个 ResizeProcessor，在 prepare 的时候，只负责将 input 的数据 push 到 output processor 去，然后继续返回 needData 的状态。</li>
</ul>

<h3>多个 sources 是在什么时候合并的？是否有固定的合并操作？</h3>

<ul>
  <li>QueryPipeline 构造时，引入 ResizeProcessor，进行多线程 inputs 的合并，之后就都是单线程操作</li>
</ul>

<h3>ISource 的 outputs 如何初始化？</h3>

<p>ISource 的 construction：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ISource</span><span class="o">::</span><span class="n">ISource</span><span class="p">(</span><span class="n">Block</span> <span class="n">header</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">IProcessor</span><span class="p">({},</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">header</span><span class="p">)}),</span> <span class="n">output</span><span class="p">(</span><span class="n">outputs</span><span class="p">.</span><span class="n">front</span><span class="p">())</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用的是 IProcessor 创建时候的 outputs 的第一个，而 IProcessor 的 outputs 是基于 header 创建的， 这里主要是创建了一个带 header 的 OutputPort。header 来自于</p>

<p>MergeTreeBaseSelectProcessor::transformHeader 操作，该操作会基于 required columns 等信息算出来的需要实际读取的 columns，也就是 OutputPort 的 header 记录的是 ISource 要读取的列名称。</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; xht - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://yous.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
