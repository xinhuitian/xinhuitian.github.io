<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>ClickHouse ExecutingGraph 相关代码分析</title>
  <meta name="description" content="Overview 每条 select query 在生成完 Processors 之后，准备执行时，都会创建一个 PullingAsyncPipelineExecutor 结构来负责整体 pipeline 的 pull 式执行，其中 pipeline 的执行是被封装在一个 PipelineExecutor 结构中管理，而 PipelineExecutor 为每个 Pipeline 的 Processors 维护了两个主要的数据结构来管理整体的执行，一个是负责管理各个 Processors 之间的调用关系和状态的 ExecutingGraph，另一个是负责具体执行的 ExecutorTasks。本文主要介绍 ExecutingGraph 的基本结构与主要方法设计。 基本结构 Node：每个 processor 建立一个，负责维护 Processor 的执行状态 updated_output_ports updated_input_ports Edge： to：连接 node 的 id input_port_number：这个 output port 对应的 input port 在 to Processor 的 inputs 中的 port number output_port_number：output port 在 from Processor 的 outputs 中的 port number update_info: Port 会操作的信息，edge 会将 update_info 的 id 设置为自己，会将 update_info 的 update_list 设置为 node 的 post_updated_input_ports (back edges) 或者是 post_updated_output_ports (direct edges) processors_map：IProcessor 到 node 的 id 的 map Construction 基于给定的 processors，包含创建 nodes 和创建 edges 两个步骤。 创建 nodes 针对给定的每个 processor，都创建一个 node，将 processor 和 node id 的对应关系保存到 processors_map 中。 创建 edges 对每个 node，调用 addEdges 方法，为每个 node 创建 edges addEdges 对一个 node 来说，首先添加其对应 processor 的 inputs，再添加其 outputs 添加 inputs / outputs 对该 node 对应的每个 input port / output port，获取其对应的 output port / input port的 processor 作为 to processor 得到 output port / input port 在 processor 中的 output port number / input port number 创建 edge:  Edge edge(0, true, from_input, output_port_number, &amp;amp;nodes[node]-&amp;gt;post_updated_input_ports); / Edge edge(0, false, input_port_number, from_output, &amp;amp;nodes[node]-&amp;gt;post_updated_output_ports); 调用 addEdge： 首先查找 to processor 是否已经在 processors_map 中了，如果不在，就会 throw exception 将 edge→to 设置为 to processor 对应的 node 将 edge 添加到 nodes[node]→back_edges / nodes[node]→direct_edges 结构中 将 edge 的 update_info.id 设置为 edge 自己 from_input 对应的 input port 设置 update info 为 edge 的 update_info initializeExecution 选出所有的没有 outputs 的 processor，也就是所有的 IOutputFormat processors 添加到 stack 中，将 node 的 status 设置为 ExecutingGraph::ExecStatus::Preparing 对于每个 stack 中的 processor，调用 updateNode updateNode 参数为 processor_id, queue, 以及 async_queue。processor_id 表示要更新哪个 node；queue 是一个同步执行的 task queue，updateNode 方法会将 ready 的 node 添加到这个 queue 中，之后由 ExecutorTasks 进行处理；async_queue 和 queue 的使用场景类似，只是只会处理 status 为 async 的 processors。 updateNode 方法在 initializeExecution 以及每个 processor 的 work 执行后会被调用，主要负责 processors 的调用前准备工作，以及 processor node 执行的调度。 对于 IOutputFormat Processor，第一次调用 prepare，会进行以下操作 /// 会将其 inputs 添加到 post_updated_input_ports 中 input.setNeeded(); if (!input.hasData()) return Status::NeedData; 对 node post_updated_input_ports 中的每个 edge，添加到 updated_edges 中，之后调用 edge→update_info.trigger() 来将 update_info 的 version+1 继续进入下一层循环，这时 updated_processors 为 empty 获取 updated_edges 最上面的 edge 得到 edge→to 指向的 node，这里应该是一条 back_edge, 所以指向的是之前 node 的一个 input 将 edge 的 output_port_number 添加到 node.updated_output_ports 中 如果 node 的 status 为 idle： 将 status 设置为 ExecutingGraph::ExecStatus::Preparing 将 edge→to 添加到 updated_processors 中 继续进行时，又进入到 update_processors 不为空的逻辑中。 如此循环，直到 updated_edges 和 updated_processors 都为空位置。 由此可见，第一次调用 processors 的 prepare 是从后往前调用的。 全部执行完之后，queue 中应该只包含 source processors, 并且这些 node 的 status 都会被设置为 ExecutingGraph::ExecStatus::Executing，其他 processors 会被设置为 ExecutingGraph::ExecStatus::Idle updateNode 在每个 processor 执行完 work 以后，还会被调用一次，只不过这次应该是从前往后调用。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://yous.github.io/2022/09/25/ClickHouse-ExecutingGraph/">
  
  
  <link rel="alternate" type="application/rss+xml" title="XinhuiTian&#39;s Note" href="https://yous.github.io/feed.xml">

  

  
  <meta property="og:title" content="ClickHouse ExecutingGraph 相关代码分析">
  <meta property="og:site_name" content="XinhuiTian&#39;s Note">
  <meta property="og:url" content="https://yous.github.io/2022/09/25/ClickHouse-ExecutingGraph/">
  <meta property="og:description" content="Overview 每条 select query 在生成完 Processors 之后，准备执行时，都会创建一个 PullingAsyncPipelineExecutor 结构来负责整体 pipeline 的 pull 式执行，其中 pipeline 的执行是被封装在一个 PipelineExecutor 结构中管理，而 PipelineExecutor 为每个 Pipeline 的 Processors 维护了两个主要的数据结构来管理整体的执行，一个是负责管理各个 Processors 之间的调用关系和状态的 ExecutingGraph，另一个是负责具体执行的 ExecutorTasks。本文主要介绍 ExecutingGraph 的基本结构与主要方法设计。 基本结构 Node：每个 processor 建立一个，负责维护 Processor 的执行状态 updated_output_ports updated_input_ports Edge： to：连接 node 的 id input_port_number：这个 output port 对应的 input port 在 to Processor 的 inputs 中的 port number output_port_number：output port 在 from Processor 的 outputs 中的 port number update_info: Port 会操作的信息，edge 会将 update_info 的 id 设置为自己，会将 update_info 的 update_list 设置为 node 的 post_updated_input_ports (back edges) 或者是 post_updated_output_ports (direct edges) processors_map：IProcessor 到 node 的 id 的 map Construction 基于给定的 processors，包含创建 nodes 和创建 edges 两个步骤。 创建 nodes 针对给定的每个 processor，都创建一个 node，将 processor 和 node id 的对应关系保存到 processors_map 中。 创建 edges 对每个 node，调用 addEdges 方法，为每个 node 创建 edges addEdges 对一个 node 来说，首先添加其对应 processor 的 inputs，再添加其 outputs 添加 inputs / outputs 对该 node 对应的每个 input port / output port，获取其对应的 output port / input port的 processor 作为 to processor 得到 output port / input port 在 processor 中的 output port number / input port number 创建 edge:  Edge edge(0, true, from_input, output_port_number, &amp;amp;nodes[node]-&amp;gt;post_updated_input_ports); / Edge edge(0, false, input_port_number, from_output, &amp;amp;nodes[node]-&amp;gt;post_updated_output_ports); 调用 addEdge： 首先查找 to processor 是否已经在 processors_map 中了，如果不在，就会 throw exception 将 edge→to 设置为 to processor 对应的 node 将 edge 添加到 nodes[node]→back_edges / nodes[node]→direct_edges 结构中 将 edge 的 update_info.id 设置为 edge 自己 from_input 对应的 input port 设置 update info 为 edge 的 update_info initializeExecution 选出所有的没有 outputs 的 processor，也就是所有的 IOutputFormat processors 添加到 stack 中，将 node 的 status 设置为 ExecutingGraph::ExecStatus::Preparing 对于每个 stack 中的 processor，调用 updateNode updateNode 参数为 processor_id, queue, 以及 async_queue。processor_id 表示要更新哪个 node；queue 是一个同步执行的 task queue，updateNode 方法会将 ready 的 node 添加到这个 queue 中，之后由 ExecutorTasks 进行处理；async_queue 和 queue 的使用场景类似，只是只会处理 status 为 async 的 processors。 updateNode 方法在 initializeExecution 以及每个 processor 的 work 执行后会被调用，主要负责 processors 的调用前准备工作，以及 processor node 执行的调度。 对于 IOutputFormat Processor，第一次调用 prepare，会进行以下操作 /// 会将其 inputs 添加到 post_updated_input_ports 中 input.setNeeded(); if (!input.hasData()) return Status::NeedData; 对 node post_updated_input_ports 中的每个 edge，添加到 updated_edges 中，之后调用 edge→update_info.trigger() 来将 update_info 的 version+1 继续进入下一层循环，这时 updated_processors 为 empty 获取 updated_edges 最上面的 edge 得到 edge→to 指向的 node，这里应该是一条 back_edge, 所以指向的是之前 node 的一个 input 将 edge 的 output_port_number 添加到 node.updated_output_ports 中 如果 node 的 status 为 idle： 将 status 设置为 ExecutingGraph::ExecStatus::Preparing 将 edge→to 添加到 updated_processors 中 继续进行时，又进入到 update_processors 不为空的逻辑中。 如此循环，直到 updated_edges 和 updated_processors 都为空位置。 由此可见，第一次调用 processors 的 prepare 是从后往前调用的。 全部执行完之后，queue 中应该只包含 source processors, 并且这些 node 的 status 都会被设置为 ExecutingGraph::ExecStatus::Executing，其他 processors 会被设置为 ExecutingGraph::ExecStatus::Idle updateNode 在每个 processor 执行完 work 以后，还会被调用一次，只不过这次应该是从前往后调用。">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="ClickHouse ExecutingGraph 相关代码分析">
  <meta name="twitter:description" content="Overview 每条 select query 在生成完 Processors 之后，准备执行时，都会创建一个 PullingAsyncPipelineExecutor 结构来负责整体 pipeline 的 pull 式执行，其中 pipeline 的执行是被封装在一个 PipelineExecutor 结构中管理，而 PipelineExecutor 为每个 Pipeline 的 Pro...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">XinhuiTian&#39;s Note</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">ClickHouse ExecutingGraph 相关代码分析</h1>
    
    <p class="post-meta"><time datetime="2022-09-25T16:08:00+00:00" itemprop="datePublished">Sep 25, 2022</time> •
  
    
    
      
    
      
        <a href="/categories/clickhouse/">ClickHouse</a>,
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/categories/pipelineexecution/">PipelineExecution</a>
      
    
      
    
      
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2>Overview</h2>

<p>每条 select query 在生成完 Processors 之后，准备执行时，都会创建一个 PullingAsyncPipelineExecutor 结构来负责整体 pipeline 的 pull 式执行，其中 pipeline 的执行是被封装在一个 PipelineExecutor 结构中管理，而 PipelineExecutor 为每个 Pipeline 的 Processors 维护了两个主要的数据结构来管理整体的执行，一个是负责管理各个 Processors 之间的调用关系和状态的 ExecutingGraph，另一个是负责具体执行的 ExecutorTasks。本文主要介绍 ExecutingGraph 的基本结构与主要方法设计。</p>

<h2>基本结构</h2>

<p>Node：每个 processor 建立一个，负责维护 Processor 的执行状态</p>

<ul>
  <li>updated_output_ports</li>
  <li>updated_input_ports</li>
</ul>

<p>Edge：</p>

<ul>
  <li>to：连接 node 的 id</li>
  <li>input_port_number：这个 output port 对应的 input port 在 to Processor 的 inputs 中的 port number</li>
  <li>output_port_number：output port 在 from Processor 的 outputs 中的 port number</li>
  <li>update_info: Port 会操作的信息，edge 会将 update_info 的 id 设置为自己，会将 update_info 的 update_list 设置为 node 的 post_updated_input_ports (back edges) 或者是 post_updated_output_ports (direct edges)</li>
</ul>

<p>processors_map：IProcessor 到 node 的 id 的 map</p>

<h2>Construction</h2>

<p>基于给定的 processors，包含创建 nodes 和创建 edges 两个步骤。</p>

<h3>创建 nodes</h3>

<p>针对给定的每个 processor，都创建一个 node，将 processor 和 node id 的对应关系保存到 processors_map 中。</p>

<h3>创建 edges</h3>

<p>对每个 node，调用 addEdges 方法，为每个 node 创建 edges</p>

<h2>addEdges</h2>

<p>对一个 node 来说，首先添加其对应 processor 的 inputs，再添加其 outputs</p>

<p>添加 inputs / outputs</p>

<ul>
  <li>对该 node 对应的每个 input port / output port，获取其对应的 output port / input port的 processor 作为 to processor</li>
  <li>得到 output port / input port 在 processor 中的 output port number / input port number</li>
  <li>创建 edge: 
<code class="language-plaintext highlighter-rouge">Edge edge(0, true, from_input, output_port_number, &amp;nodes[node]-&gt;post_updated_input_ports); / Edge edge(0, false, input_port_number, from_output, &amp;nodes[node]-&gt;post_updated_output_ports);</code></li>
  <li>调用 addEdge：
    <ul>
      <li>首先查找 to processor 是否已经在 processors_map 中了，如果不在，就会 throw exception</li>
      <li>将 edge→to 设置为 to processor 对应的 node</li>
      <li>将 edge 添加到 nodes[node]→back_edges / nodes[node]→direct_edges 结构中</li>
      <li>将 edge 的 update_info.id 设置为 edge 自己</li>
    </ul>
  </li>
  <li>from_input 对应的 input port 设置 update info 为 edge 的 update_info</li>
</ul>

<h2>initializeExecution</h2>

<p>选出所有的没有 outputs 的 processor，也就是所有的 IOutputFormat processors 添加到 stack 中，将 node 的 status 设置为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ExecutingGraph::ExecStatus::Preparing
</code></pre></div></div>

<p>对于每个 stack 中的 processor，调用 updateNode</p>

<h2>updateNode</h2>

<p>参数为 processor_id, queue, 以及 async_queue。processor_id 表示要更新哪个 node；queue 是一个同步执行的 task queue，updateNode 方法会将 ready 的 node 添加到这个 queue 中，之后由 ExecutorTasks 进行处理；async_queue 和 queue 的使用场景类似，只是只会处理 status 为 async 的 processors。</p>

<p>updateNode 方法在 initializeExecution 以及每个 processor 的 work 执行后会被调用，主要负责 processors 的调用前准备工作，以及 processor node 执行的调度。</p>

<p>对于 IOutputFormat Processor，第一次调用 prepare，会进行以下操作</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 会将其 inputs 添加到 post_updated_input_ports 中</span>
<span class="n">input</span><span class="p">.</span><span class="n">setNeeded</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">.</span><span class="n">hasData</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="n">NeedData</span><span class="p">;</span>
</code></pre></div></div>

<p>对 node post_updated_input_ports 中的每个 edge，添加到 updated_edges 中，之后调用 edge→update_info.trigger() 来将 update_info 的 version+1</p>

<p>继续进入下一层循环，这时 updated_processors 为 empty</p>

<ul>
  <li>获取 updated_edges 最上面的 edge</li>
  <li>得到 edge→to 指向的 node，这里应该是一条 back_edge, 所以指向的是之前 node 的一个 input</li>
  <li>将 edge 的 output_port_number 添加到 node.updated_output_ports 中</li>
  <li>如果 node 的 status 为 idle：
    <ul>
      <li>将 status 设置为 ExecutingGraph::ExecStatus::Preparing</li>
      <li>将 edge→to 添加到 updated_processors 中</li>
    </ul>
  </li>
</ul>

<p>继续进行时，又进入到 update_processors 不为空的逻辑中。</p>

<p>如此循环，直到 updated_edges 和 updated_processors 都为空位置。</p>

<p>由此可见，第一次调用 processors 的 prepare 是从后往前调用的。</p>

<p>全部执行完之后，queue 中应该只包含 source processors, 并且这些 node 的 status 都会被设置为</p>

<p>ExecutingGraph::ExecStatus::Executing，其他 processors 会被设置为 ExecutingGraph::ExecStatus::Idle</p>

<p>updateNode 在每个 processor 执行完 work 以后，还会被调用一次，只不过这次应该是从前往后调用。</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; xht - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://yous.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
